[![pipeline status](https://gitlab.int.tsum.com/preowned/angela/alfa/frontend/badges/develop/pipeline.svg)](https://gitlab.int.tsum.com/preowned/angela/alfa/frontend/-/commits/develop)

# Preowned Frontend
------------
Frontend сервиса [TSUM collect](https://collect.tsum.ru/) на React-стеке.

## Полезные ссылки
[JIRA](https://jira.int.tsum.com/projects/POWEB/issues)  
[Канбан доска](https://jira.int.tsum.com/secure/RapidBoard.jspa?rapidView=383)  
[Figma, Дизайн](https://www.figma.com/files/project/71862002/TSUM-Collect-web-app?fuid=1092729062133220663)  
[Канал код-ревью](https://zulip.tsum.com/#narrow/stream/493-front-mr/topic/collect)  

## Стенды:  
* [Стейбл](https://collect-stable.tsum.com/)  
* [Тестинг](https://collect-testing.tsum.com/)

## Быстрый старт
```shell
yarn install # установка зависимостей
yarn run start # запуск проекта в режиме
```

## Сборка
```shell
yarn run build # prod билд
yarn run start:prod # если нужно запустить прод билд локально
```

## Bandle Analyze
```shell
yarn run build:analyze # проверить что вообще в бандле
```

## Тестирование
```shell
yarn run test:code # прогон unit тестов
yarn run test:lint # прогон линта
yarn run test:tsc # прого тайпчекера (проверка типизации)
```

## Узкие места
- Чекаут (в целом пойдет)

Тут разбито на: чекаут, корзину, КиК. Все связи в родителе

- Фильтры (сомнительно написано)
- Роутинг - кастомный и может быть проблемой при переходе на другие инструменты

## О проекте (технически)

### SSR

> Тут простой флоу

- получаем реквест
- матчим на роуты
- берем ивенты
- запускаем
- ожидаем все
- генерим html
- респонс

### Client

> Вся соль в Application.tsx, нужно понять - делать ли запрос и из этого следует другой флоу

- remoteFx (загружаем модуль) для того что бы была модель и кто то реагировал на собития
- матичи роуты на урл и берем старт ивент
- запускаем ивент
- ожидаем ивента loaded (каждой страницы)
- выполняем переход (данные уже есть)

> Для запросов генерится свой abort controller, который если нужно - можно вызвать на отмену и не ожидать данные от сервера (полезно что бы не обрабатывать предыдущие запросы (или когда просто вышли со страницы)). Ошибка аборта фильтруется для ивента loaded (А значит аналитика не запустится, собственно как это и ожидается)

### PageHooks

> Модуль который обогащает страницу методами (start, loaded, leave, $onPage), полезно для всяких аналитик

### Remote 

> Модуль который позволяет ждать загрузки страницы (физического файла), для последующего запуска. Если файла нету - ничего не упадет и переход просто не произойдет

### Фильтры

> Самая узкая часть, в основном ожидает фильтры вида filters: T[]. Где T стандартный набор для фильтра и обрабатывается одинаково. Есть ряд исключений таких как: page, q, collections - все эти фильтры обрабатывает клиент по особенному. ТАк же из-за появления фильтра иерархичесского (по сути это collections, но другой тип и обработка как у всех). Для него есть общие правила + хардкод по code и это приводит к тому что это потенциальное место отказа в прилаге (если бек поменяет название - фильтры просто не появятся)

## Рабочий флоу

- Используем feature ветки, именуем созданную ветку кодом задачи, например `POWEB-1`.  
Создаём ветку от develop.  
- Коммиты именуем согласно семантической методологии:  
https://gist.github.com/joshbuchea/6f47e86d2510bce28f8e7f42ae84c716 
- Задачи брать из колонки backlog или to do (Доска https://jira.int.tsum.com/secure/RapidBoard.jspa?rapidView=383)  
- После выполнения задачи создаём МР.  
Целимся своей веткой в develop.  
Название МР начинаем с кода задачи, затем название-описание, например:  
`POWEB-1: Сделано это и то`  
(Можно названием МР дублировать название тикета в Jira, если трудно придумать ёмкое описательное название).  
- Кидаем свой МР в канал код-ревью https://zulip.tsum.com/#narrow/stream/493-front-mr/topic/collect  
- Таску в джире переводим в статус Code Review (жмём кнопку "На проверку").  
- После того как МР собрал 2 и более апрувов, перекинуть задачу в колонку ready for qa (жмём кнопку "Ready for QA").
(Ответственность собирать апрувы и мониторить количество собранных лежит на авторе МР) (Тестировщики далее сами разберутся что проверять и как мержить)
- Далее работают тесровщики.  
Они могут вернуть задачу на доработку, тогда нам требуется внести правки.  
Когда задача готова и прошла тестирование, тестировщики сами её упакуют в релиз и выпустят.  

## Структура проекта

- mocks - некоторые моки для тестов jest.
- public - папка со статикой, при билде копируется в сборку как есть.
- razzle - некоторые настройки конфига вебпак под razzle. (Razzle это своего рода готовая обёртка конфигуратор webpack с удобной поддержкой SSR).  
- scripts - различные вспомогательные скрипты, в основном там примечателен скрипт генерации grpc клиента из определений protobuf.
- src/index.js - самая главная точка входа проекта, с неё начинается выполнение приложения. (В большинстве задач трогать её не нужно.)
- **src/application** - входные точки проекта. (В большинстве задач трогать эти файлы не нужно.)
  - entrypoints - файлы конфигурации серверной и клиентской сборки, они ключевое звено при сборке соответствующих бандлов.  
  - server - код необходимый для серверной части проекта, это та часть которая отвечает за пререндеринг страницы (SSR).  
  - Application.tsx - корневой компонент приложения.  
  - hmr.ts - настройки горячей замены модулей (Hot Module Replacement) для effector.  
- src/constants - определения различных важных констант используемых по всему проекту.  
- **src/features** - цельные фичи или группа фич проекта. Включают в себя - логику, аналитику, компоненты, фабрики.  
Каждая фича в отдельной подпапке.  
Фича обязана экспортить "на внешку" всё через index.ts файл. Прямые импорты внутренних компонентов (т.е. не из модуля (неявного index)) вне фичи недопускаются!  
Внутри фичи прямые импорты своих-же компонентов допускаются.  
Также в фичах могут быть следующие файлы со смыслом:  
  - api.ts - сюда помещаются функции взаимодействия с апи (в нашем случае вызовы grpc клиента или createQuery/createMutation).  
  - model.ts - сюда помещаем данные логики на эффекторе и необходимые для фичи в общем.  
  - models/ - создаём папку с моделями, если понимаем, что один файл model.ts это (уже) неудобно. Суть использования такая же как и описание про файл model.ts выше.  
  Рассматриваем этот файл как модуль, т.е. все экспорты во внешку через index.ts.  
- src/generated - файлы grpc клиентов, сгенерированные как результат запуска скрипта scripts/generate.sh  
- src/i18n - данные о переводах локализованных/интернализованных строк. Обычно это результат работы npm команд locales:extract и locales:compile.   
- **src/lib** - то что можно использовать отдельно от проекта (не завязано на бизнес требования).  
  - hooks - хуки, экспортим во вне их через hooks/index.ts, прямые импорты хуков извне этой папки не допускаются, всё импортим будто модуль через неявный index.  
  - services - абстракции взаимодействия со внешними сервисами, такими как cookies, firebase. В основном к ним можно получить доступ в проекте через useBaseServices или внутри эффектора через стор $baseServices.  
  Но перед тем как лезть в них напрямую, задумайтесь, а не костыль-ли это? Возможно уже существует какая-то обёртка абстракция над ними удобная для пользовательского слоя. Если сами не нашли, спросите у команды.  
- **src/pages** - все страницы проекта. Каждая страница в своей подпапке.
При создании новой страницы можно взять основу от какой-то другой сущетсвующей, т.к. некоторая часть бойлерплейта схожа (особенно важен index.ts).  
Важны следующие файлы в подпапке страницы:  
  - index.ts - точка входа страницы, также там размещается код lazy-loading'а этой страницы.
  - model.ts - данные и логика которые нужны только для этой страницы, тут же уместно производить предзапрос данных для отрисовки страницы и т.п.
  - Файл page.tsx - сам компонент страницы, обычно там вёрстка + привязки сторов + хуки по мелочи.  
  - styles.module.scss - стили, подключаем в page.tsx.  
Все страницы дефолтные (для примера можно брать /pages/Errors/error404)
- **src/shared** - что то совсем глобальное (включать в себя может компоненты и логику). В целом тут применима логика организации про модель и модульность, как было описано выше про фичи.
- src/tests - мок данные и вспомогательный код для тестов.
- **src/ui** - простейшие компоненты на основе которых делаем верстку.  
Считай ui-kit. Тоже всё экспортим модулем через index.ts.  
- .env.development - файл с конфигурациями env переменных, используемых для запуска проекта в режиме разработчика.
- .env.production - этот файл создаём самостоятельно, если нужно задать переменные для локального запуска продовой сборки. (Обычно создаём этот файл просто копированием .env.development и дальнейшим переименованием).
- прочие файлы в корне проекта это файлы различных конфигов инструментария, например package.json, tsconfig, eslint, и пр. Упражнение к читателю погуглить применение этих файлов самостоятельно, если есть интерес или необходимость.  

## Именование

- Модели
> сторы - $store

> эффекты - nameFx

> ивенты - someChanged

> обновление сторов ($store.on(someChanged, () => data))

> связи и фибрики (sample, someFactory)

- Компоненты
Включает в себя файлы: styles.module.scss, View.tsx, index.ts. Одинаково для сложных и простых компонентов. Можно включать подгруппы

- Страницы
Включает в себя файлы: styles.module.scss, Page.tsx, index.ts(x). Одинаково для всех страниц. Модель требуется если данные только на текущей странице (Так же везде обязательно будет модель дефолтная. Пример /pages/Errors/error404)

## Генерация из прото

Из конря проекта нужно запустить команду

```shell
sh scripts/generate.sh
```

Затем ввести пароль администратора. Скрипт спулит репу с прото файлами и сгенерит ts файлы положив их в src/generated. Клиент grpc находится в lib/grpc

### Локализация
```shell
yarn run locales:extract # Выборка всех локалей
yarn run locales compile # Компиляция json в js файлы
````

Юзается либа Lingui:

```js
import { t } from '@lingui/macro'

// Макрос вытянет значения и положит в конфиг
// Для ру нужно будет дописать перевод
// Писать строго так же в тильде
render(() => {
  return <p>{t`Welcome back`}</p>
})
```

Это базовый пример, но может понадобится динамические типы (ответ с сервера и тд)
Тут не подходит макрос нужно юзать кор

```js
import { i18n } from '@lingui/core'

// тут нету макроса,
// соответсвенно добавить в json ключи нужно руками
render(() => {
  return ['server response1'].map(key =>
    <p>{i18n._(key)}</p>
  )
})
```

Порядок действий:
- Написать код
- `yarn run locales:extract` (если был не макрос - руками ключи) - покажет таблицу и сколько полей не перевели
- переводим для `ru` языка
- `yarn run locales:compile` (собираем жс файл из жсон)

Писать сообщения длинные - это нормально. Писать сообщение с переменной тоже (t`Some message ${var} and next`).

# Хардкод

в коде искать комментарий // COLLECT_HARDCODE, src/constants/hardcode.ts
